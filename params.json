{"name":"Mockito","tagline":"Proyecto de pruebas en base a Mockito","body":"### Welcome to Mockito \r\n\r\nTodo el código que escribimos tiene una red de interdependencias, en una clase se puede llamar a los métodos de otras que a su vez pueden llamar aún otros métodos; de hecho esta es la intención y el poder de la programación orientada a objetos. Por lo general, al tiempo que escribimos nuestro código de funcionalidad también vamos a escribir código de pruebas unitarias automatizadas. Utilizamos estas pruebas de unidad para verificar el comportamiento de nuestro código, para asegurarse de que se comporta como esperamos que se comporte. Cuando la unidad a prueba nuestro código queremos probarlo en aislamiento y queremos probarlo rápido. A los efectos de la prueba de unidad sólo nos preocupamos por la verificación de nuestro propio código, en la clase actual bajo prueba. Generalmente también queremos ejecutar nuestras pruebas unitarias muy regularmente, quizás más que varias veces por hora cuando se reestructuran y estamos trabajando en nuestro entorno de integración continua.\r\n\r\nAqui es cuando todas nuestras interdependencias convierten en un problema. Podríamos llegar a ejecutar código en otra clase que tiene un error que hace que nuestra unidad de prueba falle. Imagina una clase que utilizamos para leer datos de usuario de una base de datos, que sucede si no hay base de datos presente cuando queremos ejecutar nuestras pruebas unitarias? Imagina una clase que requiere varios servicios web remotos, lo que si están abajo o tardan mucho tiempo para responder? Nuestras pruebas unitarias pueden fallar debido a nuestras dependencias y no debido a algún problema con el comportamiento de nuestro código. Esto no es deseable.\r\n\r\nAdemás de esto, puede ser que sea muy difícil  obligar a un evento específico o una condición de error que queremos asegurar nuestro código maneja correctamente. ¿Qué pasa si queremos probar que alguna clase que deserializar un objeto maneja una posible StreamException Objeto correctamente? ¿Qué pasa si queremos probar todos los valores de retorno de contorno de un colaborador? Lo que trata de asegurar que un cierto valor calculado se pasa correctamente a un colaborador? Puede ser que tome un montón de codificación y mucho tiempo para replicar las condiciones para nuestras pruebas, si es no que seria impoposible.\r\n\r\nTodos estos problemas simplemente desaparecen si utilizamos _mocks_. Un `burla`  actua como un sustituto de las clases con las que estamos colaborando, toman su lugar y se comportan exactamente como les decimos a comportarse. Mocks vamos a pretender que nuestros colaboradores reales están ahí, a pesar de que no lo son. Más importante _mocks_ se pueden programar para volver cualesquiera valores que queremos y confirmar lo valores se pasan a ellos. Mocks ejecutar inmediatamente y no requieren recursos externos. Mocks devolverá lo que les decimos a regresar, lanzar excepciones lo que queremos que tire y haremos estas cosas una y otra vez, bajo demanda. Nos dejaron probar sólo el comportamiento de nuestro propio código, para asegurarse de que nuestra clase trabaja, independientemente del comportamiento de sus colaboradores.\r\n\r\nHay varios Frameworks de mocks disponibles para Java, cada uno tiene su propia sintaxis, sus puntos fuertes, sus propias debilidades. En este tutorial vamos a utilizar el Framework Mockito, que es uno de los marcos de _mocks_ más populares disponibles.\r\n\r\nMockito encourages standard best practices in unit testing and design in general, namely:\r\n\r\n* Mockito does not have a provision for mocking static methods because Mockito encourages object oriented design and dependency injection over procedural code.\r\n* Mockito does not have a provision for mocking private methods because public methods should be black boxes and from the standpoint of testing private methods don’t exist.\r\n* Mockito packages and encourages the usage of Hamcrest Matchers, which will be covered in subsequent tutorials.\r\n* Mockito encourages adherence to the Law of Demeter and does not encourage mocking chained methods.\r\n* You should not stub or verify on a mock which is shared between different threads. You may call the methods of a shared mock, however.\r\n* You can’t verify the toString() method of a mock, due to the fact that it may be called by the test environment itself, making verification impossible.\r\n* If your test cases use the Given When Then notation you can use the stubbing methods from org.mockito.BDDMockito so that when(mock.method()).thenReturn(something) becomes given(mock.method()).willReturn(something) as it will read nicely in your test format.\r\n* It is possible to use Mockito without the Mockito annotations, however it is much easier and neater to use the annotations so that is what we will do in these tutorials.\r\n* You can ‘spy’ on any class, including the class under test if your testing requires that you modify the behaviour of a particular method of the class for the purposes of the test. Mockito explicitly recommends that spies should be only used carefully and occasionally, for instance when constrained by dealing with legacy code. This will be covered in a future tutorial.\r\n* In the event that the real call into a spied method could generate an error condition or cannot be called for some other reason Mockito recommends using the do* family of methods for stubbing. This will be covered in a future tutorial.\r\n* Mockito will allow you to use argument matchers in place of real arguments with the limitation that if one argument uses a matcher, all must use matchers. Argument matchers will be covered in a later tutorial but should probably be used sparingly.\r\n* Mockito provides a verifyNoMoreInteractions() method to verify that a particular mock has no more interactions but recommends that it is used very sparingly and only when appropriate.\r\n* Mockito provides the Answer interface to allow for stubbing with callbacks, however it recommends against using it and encourages you to do simple stubbing using the thenReturn() and doThrow() methods. We will cover Answers in a later tutorial.\r\n* If using ArgumentCaptor for argument validation you should use it only in the verification phase, and not the stubbing phase. ArgumentCaptor will be covered in a future tutorial.\r\n* Mockito recommends to use Partial Mocks very carefully, mainly when dealing with legacy code. Well designed code should not require the use of partial mocks.\r\n* Mockito provides a reset() method for resetting your mock in the middle of a test method, however it recommends against using it as it is a code smell that your test may be overly long and complex.\r\n* There are more features and practices, but these are the main ones which Mockito tells you to watch out for. We will cover all of the above and more in depth in the coming tutorials.\r\n\r\n\r\n### Authors and Contributors\r\nJuan Manuel Hernandez (aka Juan Perez Jolote) (@sidlors)\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out our [documentation](https://help.github.com/pages) or [contact support](https://github.com/contact) and we’ll help you sort it out.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}